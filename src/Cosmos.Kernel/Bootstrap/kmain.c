typedef unsigned int size_t;

#include <stdint.h>

// A function decorated either with `UnmanagedCallersOnly` or `RuntimeExport` attributes in `Cosmos.Kernel`
extern void __Initialize_Kernel();
// Generated by ilc at compile time when the parameter `--nativelib` is present.
extern void __managed__Startup();
// Tentative name, this function would be exposed by the User's Main Project.
extern void __managed__Main();

// This field is inspected from the generated code to determine what intrinsics are available.
extern int g_cpuFeatures;
int g_cpuFeatures = 0;

// This field is defined in the generated code and sets the ISA expectations.
extern int g_requiredCpuFeatures;

#ifdef __x86_64__
// Platform-specific initialization for x64 (enabling SSE)
extern void EnableSSE();
#endif

#ifdef __aarch64__
// Platform-specific initialization for ARM64 (enabling NEON/FP)
extern void __arm64_enable_neon(void);
extern void __arm64_disable_alignment_check(void);
#endif

extern void* __Modules_start[]; // Start of __modules Section
extern void* __Modules_end[];   // End of __modules Section

// EH frame symbols for exception handling
extern char __eh_frame_start[];
extern char __eh_frame_end[];
extern char __dotnet_eh_table_start[];
extern char __dotnet_eh_table_end[];

#ifdef ARCH_X64
// ACPI early initialization (must run before managed code) - x64 only
extern void acpi_early_init(void* rsdp_address);
extern void* __get_limine_rsdp_address(void);  // C# function to get RSDP from Limine
#endif

extern void __cosmos_serial_write(const char* message);  // C# function for serial logging
extern void __cosmos_serial_write_hex_u64(uint64_t value);  // C# function for hex printing

// Entry point
void kmain()
{
#ifdef __x86_64__
    EnableSSE();
#endif

#ifdef __aarch64__
    // ARM64: Enable NEON/FP (SIMD) - must be done before any SIMD instructions
    __arm64_enable_neon();
    // ARM64: Disable alignment checking - NativeAOT generates unaligned accesses
    __arm64_disable_alignment_check();
#endif

    __cosmos_serial_write("[KMAIN] Starting kernel bootstrap...\n");

#ifdef ARCH_X64
    // Get RSDP address from Limine (via C# static data)
    void* rsdp_address = __get_limine_rsdp_address();

    // Initialize ACPI early (before managed code needs it)
    if (rsdp_address != 0)
    {
        __cosmos_serial_write("[KMAIN] RSDP found at: ");
        __cosmos_serial_write_hex_u64((uint64_t)rsdp_address);
        __cosmos_serial_write("\n");

        __cosmos_serial_write("[KMAIN] Calling acpi_early_init()...\n");
        acpi_early_init(rsdp_address);
        __cosmos_serial_write("[KMAIN] acpi_early_init() completed\n");
    }
    else
    {
        __cosmos_serial_write("[KMAIN] ERROR: RSDP not found from Limine!\n");
    }
#else
    __cosmos_serial_write("[KMAIN] ACPI initialization skipped (ARM64 platform)\n");
#endif

    __cosmos_serial_write("[KMAIN] Initializing managed kernel...\n");
    __Initialize_Kernel();
    __managed__Startup();
    __managed__Main();
}

// Return the size of the '__modules' section and
// populates 'modules' with a pointer to the start of the section.
extern size_t GetModules(void** modules)
{
    *modules = __Modules_start;
    //return sizeof(size_t);
    return  __Modules_end - __Modules_start;
}

// Exception handling section accessors
// These functions return the start/end addresses of EH data sections
void* get_eh_frame_start(void)
{
    return __eh_frame_start;
}

void* get_eh_frame_end(void)
{
    return __eh_frame_end;
}

void* get_dotnet_eh_table_start(void)
{
    return __dotnet_eh_table_start;
}

void* get_dotnet_eh_table_end(void)
{
    return __dotnet_eh_table_end;
}
