<Project>
  <!-- Disable standard ILLink - Cosmos uses custom NativeAOT compilation via Cosmos.Build.Ilc -->
  <!-- This prevents the "Missing predefined 'System.NotSupportedException' type" error -->
  <Target Name="_RunILLink" />
  <Target Name="ILLink" />

  <!-- Resolve Bootstrap from Cosmos.Kernel (project reference or package) -->
  <Target Name="ResolveCosmosKernelBootstrap" BeforeTargets="BuildGCC">
    <ItemGroup>
      <!-- Find Cosmos.Kernel project reference -->
      <_CosmosKernelProjectRef Include="@(ProjectReference)" Condition="$([System.String]::Copy('%(Filename)').EndsWith('Cosmos.Kernel'))" />
    </ItemGroup>

    <PropertyGroup>
      <!-- Get the directory of the Cosmos.Kernel project for project references -->
      <_CosmosKernelProjectDir Condition="@(_CosmosKernelProjectRef) != ''">$([System.IO.Path]::GetDirectoryName('%(_CosmosKernelProjectRef.Identity)'))\</_CosmosKernelProjectDir>
    </PropertyGroup>

    <ItemGroup Condition="'$(_CosmosKernelProjectDir)' != '' AND Exists('$(_CosmosKernelProjectDir)Bootstrap\')">
      <!-- Add Bootstrap from project reference location -->
      <GCCProject Include="$(_CosmosKernelProjectDir)Bootstrap\" />
    </ItemGroup>

    <Message Importance="High" Text="⚙️ [SDK] Cosmos.Kernel Bootstrap: $(_CosmosKernelProjectDir)Bootstrap\" Condition="'$(_CosmosKernelProjectDir)' != ''" />
  </Target>

  <!-- Generate Cosmos entry point with the user's kernel class -->
  <Target Name="GenerateCosmosEntryPoint" BeforeTargets="BeforeCompile">
    <PropertyGroup>
      <CosmosEntryPointFile>$(IntermediateOutputPath)CosmosEntryPoint.g.cs</CosmosEntryPointFile>
      <CosmosEntryPointContent>
// Auto-generated by Cosmos.Sdk - DO NOT EDIT
namespace Cosmos.Kernel.System.Internal%3B

internal static class CosmosEntryPoint
{
    private static void Main()
    {
        Cosmos.Kernel.System.Global.RegisterKernel(new global::$(CosmosKernelClass)())%3B
        Cosmos.Kernel.System.Global.StartKernel()%3B
    }
}
      </CosmosEntryPointContent>
    </PropertyGroup>
    <WriteLinesToFile File="$(CosmosEntryPointFile)" Lines="$(CosmosEntryPointContent)" Overwrite="true" />
    <ItemGroup>
      <Compile Include="$(CosmosEntryPointFile)" />
    </ItemGroup>
  </Target>

  <!-- Resolves the path of 'ilc' to IlcToolsPath. -->
  <Target Name="ResolveIlcPath" BeforeTargets="CustomizeReferences" DependsOnTargets="ResolvePackageAssets">
    <ItemGroup>
      <!-- For ARM64 cross-compilation, always use x64 ILC tools -->
      <HostILCompilerPack Include="runtime.linux-x64.Microsoft.DotNet.ILCompiler"
                          Condition="'$(RuntimeIdentifier)' == 'linux-arm64'">
        <NuGetPackageVersion>$(BundledNETCoreAppPackageVersion)</NuGetPackageVersion>
        <NuGetPackageId>runtime.linux-x64.Microsoft.DotNet.ILCompiler</NuGetPackageId>
      </HostILCompilerPack>

      <NAOTRuntimePack Include="Microsoft.NETCore.App.Runtime.NativeAOT.$(RuntimeIdentifier)">
        <NuGetPackageVersion>$(BundledNETCoreAppPackageVersion)</NuGetPackageVersion>
        <NuGetPackageId>Microsoft.NETCore.App.Runtime.NativeAOT.$(RuntimeIdentifier)</NuGetPackageId>
      </NAOTRuntimePack>

      <!-- For all other architectures, use native ILC -->
      <HostILCompilerPack Include="runtime.$(RuntimeIdentifier).Microsoft.DotNet.ILCompiler"
                          Condition="'$(RuntimeIdentifier)' != 'linux-arm64'">
        <NuGetPackageVersion>$(BundledNETCoreAppPackageVersion)</NuGetPackageVersion>
        <NuGetPackageId>runtime.$(RuntimeIdentifier).Microsoft.DotNet.ILCompiler</NuGetPackageId>
      </HostILCompilerPack>
    </ItemGroup>

    <GetPackageDirectory
      Items="@(NAOTRuntimePack)"
      PackageFolders="@(AssetsFilePackageFolder)"
    >

      <Output TaskParameter="Output" ItemName="ResolvedRuntimePack" />
    </GetPackageDirectory>
    
    <GetPackageDirectory
      Items="@(HostILCompilerPack)"
      PackageFolders="@(AssetsFilePackageFolder)"
    >

      <Output TaskParameter="Output" ItemName="ResolvedILCompilerPack" />
    </GetPackageDirectory>

    <!-- Pick one matching package directory instead of joining multiple values with semicolons.
         Prefer the runtime package that contains a 'runtimes/<RID>/native' directory; otherwise fall back to any found package directory. -->
    <ItemGroup>
      <!-- find the runtime pack(s) that actually contain the native folder for this RID -->
      <ResolvedRuntimeNative Include="@(ResolvedRuntimePack)"
                             Condition="Exists('%(ResolvedRuntimePack.PackageDirectory)/runtimes/$(RuntimeIdentifier)/native')" />

      <!-- If ResolvedRuntimeNative is empty, we'll fall back to the first ResolvedRuntimePack item -->
      <ResolvedRuntimeFallback Include="@(ResolvedRuntimePack)" Condition="@(ResolvedRuntimeNative->Count()) == 0" />

      <!-- pick ILCompiler host package dir that contains tools (should be unique) -->
      <ResolvedIlcHostWithTools Include="@(ResolvedILCompilerPack)"
                                Condition="Exists('%(ResolvedILCompilerPack.PackageDirectory)/tools')" />
      <ResolvedIlcHostFallback Include="@(ResolvedILCompilerPack)" Condition="@(ResolvedIlcHostWithTools->Count()) == 0" />
    </ItemGroup>

    <PropertyGroup>
      <IlcHostPackagePath Condition="@(ResolvedIlcHostWithTools) != ''">%(ResolvedIlcHostWithTools.PackageDirectory)</IlcHostPackagePath>
      <IlcHostPackagePath Condition="@(ResolvedIlcHostWithTools) == '' and @(ResolvedIlcHostFallback) != ''">%(ResolvedIlcHostFallback.PackageDirectory)</IlcHostPackagePath>

      <IlcRuntimePackagePath Condition="@(ResolvedRuntimeNative) != ''">%(ResolvedRuntimeNative.PackageDirectory)</IlcRuntimePackagePath>
      <IlcRuntimePackagePath Condition="@(ResolvedRuntimeNative) == '' and @(ResolvedRuntimeFallback) != ''">%(ResolvedRuntimeFallback.PackageDirectory)</IlcRuntimePackagePath>

      <IlcSdkPath Condition="$(IlcRuntimePackagePath) != ''">$([MSBuild]::NormalizePath('$(IlcRuntimePackagePath)/runtimes/$(RuntimeIdentifier)/native/'))</IlcSdkPath>
      <IlcFrameworkPath Condition="$(IlcHostPackagePath) != ''">$([MSBuild]::NormalizePath('$(IlcRuntimePackagePath)/runtimes/$(RuntimeIdentifier)/lib/net10.0/'))</IlcFrameworkPath>
      <IlcToolsPath Condition="$(IlcHostPackagePath) != ''">$([MSBuild]::NormalizePath('$(IlcHostPackagePath)/tools/'))</IlcToolsPath>
    </PropertyGroup>
    <Message Importance="High" Text="⚙️ [ILC] Using ILCompiler from: $(IlcToolsPath)" />
    <Message Importance="High" Text="⚙️ [ILC] Using SDK Path: $(IlcSdkPath)" />
    <Message Importance="High" Text="⚙️ [ILC] Using Framework Path: $(IlcFrameworkPath)" />
  </Target>

  <Target Name="CustomizeReferences" BeforeTargets="SetupPatcher">
    <ItemGroup>
      <PrivateSdkAssemblies Include="$(IlcSdkPath)**/*.dll"/>
      <FrameworkAssemblies Include="$(IlcFrameworkPath)**/*.dll"/>
      <ReferencePath Remove="@(ReferencePath)" Condition="'%(ReferencePath.ReferenceOutputAssembly)' != 'true' and '%(ReferencePath.NuGetSourceType)' != 'Package'" />
    </ItemGroup>
  </Target>
  
  <!-- Ilc Generates an Invalid Exports File for ld, here we clean it up -->
  <Target Name="CleanVersionScript" AfterTargets="CompileWithIlc" BeforeTargets="LinkTarget" Condition="$(ExportsFile) != ''">
    <PropertyGroup>
      <__Semicolon>;</__Semicolon>
    </PropertyGroup>

    <!-- Read the original version script -->
    <ReadLinesFromFile File="$(ExportsFile)">
      <Output TaskParameter="Lines" ItemName="RawVersionScriptLines" />
    </ReadLinesFromFile>

    <!-- Filter out lines that are just semicolons -->
    <ItemGroup>
      <CleanedVersionScriptLines Include="@(RawVersionScriptLines)"  Condition="$([System.String]::new('%(RawVersionScriptLines.Identity)').Trim().Equals($(__Semicolon)).ToString()) == 'False'" />
    </ItemGroup>

    <!-- Override file with Cleaned Lines -->
    <WriteLinesToFile
      File="$(ExportsFile)"
      Lines="@(CleanedVersionScriptLines)"
      Overwrite="true" />
  </Target>
</Project>
