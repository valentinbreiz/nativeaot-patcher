<Project>
  <!-- Resolves the path of 'ilc' to IlcToolsPath. -->
  <Target Name="ResolveIlcPath" BeforeTargets="CustomizeReferences" DependsOnTargets="ResolvePackageAssets">
    <ItemGroup>
      <!-- For ARM64 cross-compilation, always use x64 ILC tools -->
      <HostILCompilerPack Include="runtime.linux-x64.Microsoft.DotNet.ILCompiler"
                          Condition="'$(RuntimeIdentifier)' == 'linux-arm64'">
        <NuGetPackageVersion>$(BundledNETCoreAppPackageVersion)</NuGetPackageVersion>
        <NuGetPackageId>runtime.linux-x64.Microsoft.DotNet.ILCompiler</NuGetPackageId>
      </HostILCompilerPack>

      <NAOTRuntimePack Include="Microsoft.NETCore.App.Runtime.NativeAOT.$(RuntimeIdentifier)">
        <NuGetPackageVersion>$(BundledNETCoreAppPackageVersion)</NuGetPackageVersion>
        <NuGetPackageId>Microsoft.NETCore.App.Runtime.NativeAOT.$(RuntimeIdentifier)</NuGetPackageId>
      </NAOTRuntimePack>

      <!-- For all other architectures, use native ILC -->
      <HostILCompilerPack Include="runtime.$(RuntimeIdentifier).Microsoft.DotNet.ILCompiler"
                          Condition="'$(RuntimeIdentifier)' != 'linux-arm64'">
        <NuGetPackageVersion>$(BundledNETCoreAppPackageVersion)</NuGetPackageVersion>
        <NuGetPackageId>runtime.$(RuntimeIdentifier).Microsoft.DotNet.ILCompiler</NuGetPackageId>
      </HostILCompilerPack>
    </ItemGroup>

    <GetPackageDirectory
      Items="@(NAOTRuntimePack)"
      PackageFolders="@(AssetsFilePackageFolder)"
    >

      <Output TaskParameter="Output" ItemName="ResolvedRuntimePack" />
    </GetPackageDirectory>
    
    <GetPackageDirectory
      Items="@(HostILCompilerPack)"
      PackageFolders="@(AssetsFilePackageFolder)"
    >

      <Output TaskParameter="Output" ItemName="ResolvedILCompilerPack" />
    </GetPackageDirectory>

    <!-- Pick one matching package directory instead of joining multiple values with semicolons.
         Prefer the runtime package that contains a 'runtimes/<RID>/native' directory; otherwise fall back to any found package directory. -->
    <ItemGroup>
      <!-- find the runtime pack(s) that actually contain the native folder for this RID -->
      <ResolvedRuntimeNative Include="@(ResolvedRuntimePack)"
                             Condition="Exists('%(ResolvedRuntimePack.PackageDirectory)/runtimes/$(RuntimeIdentifier)/native')" />

      <!-- If ResolvedRuntimeNative is empty, we'll fall back to the first ResolvedRuntimePack item -->
      <ResolvedRuntimeFallback Include="@(ResolvedRuntimePack)" Condition="@(ResolvedRuntimeNative->Count()) == 0" />

      <!-- pick ILCompiler host package dir that contains tools (should be unique) -->
      <ResolvedIlcHostWithTools Include="@(ResolvedILCompilerPack)"
                                Condition="Exists('%(ResolvedILCompilerPack.PackageDirectory)/tools')" />
      <ResolvedIlcHostFallback Include="@(ResolvedILCompilerPack)" Condition="@(ResolvedIlcHostWithTools->Count()) == 0" />
    </ItemGroup>

    <PropertyGroup>
      <IlcHostPackagePath Condition="@(ResolvedIlcHostWithTools) != ''">%(ResolvedIlcHostWithTools.PackageDirectory)</IlcHostPackagePath>
      <IlcHostPackagePath Condition="@(ResolvedIlcHostWithTools) == '' and @(ResolvedIlcHostFallback) != ''">%(ResolvedIlcHostFallback.PackageDirectory)</IlcHostPackagePath>

      <IlcRuntimePackagePath Condition="@(ResolvedRuntimeNative) != ''">%(ResolvedRuntimeNative.PackageDirectory)</IlcRuntimePackagePath>
      <IlcRuntimePackagePath Condition="@(ResolvedRuntimeNative) == '' and @(ResolvedRuntimeFallback) != ''">%(ResolvedRuntimeFallback.PackageDirectory)</IlcRuntimePackagePath>

      <IlcSdkPath Condition="$(IlcRuntimePackagePath) != ''">$([MSBuild]::NormalizePath('$(IlcRuntimePackagePath)/runtimes/$(RuntimeIdentifier)/native/'))</IlcSdkPath>
      <IlcFrameworkPath Condition="$(IlcHostPackagePath) != ''">$([MSBuild]::NormalizePath('$(IlcRuntimePackagePath)/runtimes/$(RuntimeIdentifier)/lib/net10.0/'))</IlcFrameworkPath>
      <IlcToolsPath Condition="$(IlcHostPackagePath) != ''">$([MSBuild]::NormalizePath('$(IlcHostPackagePath)/tools/'))</IlcToolsPath>
    </PropertyGroup>
    <Message Importance="High" Text="⚙️ [ILC] Using ILCompiler from: $(IlcToolsPath)" />
    <Message Importance="High" Text="⚙️ [ILC] Using SDK Path: $(IlcSdkPath)" />
    <Message Importance="High" Text="⚙️ [ILC] Using Framework Path: $(IlcFrameworkPath)" />
  </Target>

  <Target Name="CustomizeReferences" BeforeTargets="SetupPatcher">
    <ItemGroup>
      <PrivateSdkAssemblies Include="$(IlcSdkPath)**/*.dll"/>
      <FrameworkAssemblies Include="$(IlcFrameworkPath)**/*.dll"/>
      <ReferencePath Remove="@(ReferencePath)" Condition="'%(ReferencePath.ReferenceOutputAssembly)' != 'true' and '%(ReferencePath.NuGetSourceType)' != 'Package'" />
    </ItemGroup>
  </Target>
  
  <!-- Ilc Generates an Invalid Exports File for ld, here we clean it up -->
  <Target Name="CleanVersionScript" AfterTargets="CompileWithIlc" BeforeTargets="LinkTarget" Condition="$(ExportsFile) != ''">
    <PropertyGroup>
      <__Semicolon>;</__Semicolon>
    </PropertyGroup>

    <!-- Read the original version script -->
    <ReadLinesFromFile File="$(ExportsFile)">
      <Output TaskParameter="Lines" ItemName="RawVersionScriptLines" />
    </ReadLinesFromFile>

    <!-- Filter out lines that are just semicolons -->
    <ItemGroup>
      <CleanedVersionScriptLines Include="@(RawVersionScriptLines)"  Condition="$([System.String]::new('%(RawVersionScriptLines.Identity)').Trim().Equals($(__Semicolon)).ToString()) == 'False'" />
    </ItemGroup>

    <!-- Override file with Cleaned Lines -->
    <WriteLinesToFile
      File="$(ExportsFile)"
      Lines="@(CleanedVersionScriptLines)"
      Overwrite="true" />
  </Target>
</Project>
