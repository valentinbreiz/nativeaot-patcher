using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Liquip.API.Attributes;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace Liquip.XSharp.SourceGenerator;

/// <summary>
/// A sample source generator that creates a custom report based on class properties. The target class should be annotated with the 'Generators.ReportAttribute' attribute.
/// When using the source code as a baseline, an incremental source generator is preferable because it reduces the performance overhead.
/// </summary>
[Generator]
public class XSharpStubMakerSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context) =>
        // Generate the source code.
        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right));


    /// <summary>
    /// Generate code action.
    /// It will be executed on specific nodes (ClassDeclarationSyntax annotated with the [Report] attribute) changed by the user.
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
    /// <param name="classDeclarations">Nodes annotated with the [Report] attribute that trigger the generate action.</param>
    private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        // Go through all filtered class declarations.
        foreach (ClassDeclarationSyntax? classDeclarationSyntax in classDeclarations)
        {
            // We need to get semantic model of the class to retrieve metadata.
            SemanticModel? semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            // Symbols allow us to get the compile-time information.
            if (ModelExtensions.GetDeclaredSymbol(semanticModel, classDeclarationSyntax) is not INamedTypeSymbol
                classSymbol)
            {
                continue;
            }

            string? namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            // 'Identifier' means the token of the node. Get class name from the syntax node.
            string? className = classDeclarationSyntax.Identifier.Text;

            // Go through all class members with a particular type (property) to generate method lines.
            IEnumerable<string>? methodBody = classSymbol.GetMembers()
                .OfType<IPropertySymbol>()
                .Select(p =>
                    $@"        yield return $""{p.Name}:{{this.{p.Name}}}"";"); // e.g. yield return $"Id:{this.Id}";

            // Build up the source code
            string? code = $@"// <auto-generated/>

using System;
using System.Collections.Generic;

namespace {namespaceName};

partial class {className}
{{
    public IEnumerable<string> Report()
    {{
{string.Join("\n", methodBody)}
    }}
}}
";

            // Add the source code to the compilation.
            context.AddSource($"{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }

    private string BuildClass(ClassDeclarationSyntax classDeclaration)
    {
        ImmutableList<SyntaxNode>? methods = classDeclaration
            .ChildNodes()
            .Where(i => i is MethodDeclarationSyntax)
            .ToImmutableList();
        StringBuilder? stringBuilder = new();
        foreach (SyntaxNode? method in methods)
        {
            BuildMethod(stringBuilder, method.s as IMethodSymbol);
        }
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="stringBuilder"></param>
    /// <param name="methodSymbol"></param>
    private void BuildMethod(StringBuilder stringBuilder, IMethodSymbol methodSymbol)
    {
        string? methodName = methodSymbol.Name;
        string? xSharpMethodName = "__" + methodSymbol.Name;
        // int number, string name
        string? parameters = string.Join(",", methodSymbol.Parameters.Select(p => $"{p.Type} {p.Name}"));
        // number, name
        string? arguments = string.Join(",", methodSymbol.Parameters.Select(p => p.Name));

        string? returnType = methodSymbol.ReturnType.Name == "Void" ? "" : methodSymbol.ReturnType.Name;

        stringBuilder.Append($@"
            public partial {returnType} {methodName}({parameters})
            {{
                {(returnType == "" ? "" : "return")} {xSharpMethodName}({arguments}));
            }}
            [DllImport(""xsharpLib"", EntryPoint = ""UnmanagedTest"", CallingConvention = CallingConvention.Cdecl)]
            static extern void UnmanagedTest();
            ");
    }
}
