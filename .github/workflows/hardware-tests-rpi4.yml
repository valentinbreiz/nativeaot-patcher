name: Hardware Tests (Raspberry Pi 4B)

on:
  # Manual trigger for hardware tests
  workflow_dispatch:
    inputs:
      test_kernel:
        description: 'Test kernel to run'
        required: true
        default: 'TypeCasting'
        type: choice
        options:
          - HelloWorld
          - Memory
          - TypeCasting
          - All
      timeout:
        description: 'Test timeout in seconds'
        required: false
        default: '180'
        type: string

  # Trigger on specific label
  pull_request:
    types: [labeled]

permissions:
  contents: read
  checks: write
  pull-requests: write

# Only run one hardware test at a time (hardware is a shared resource)
concurrency:
  group: hardware-tests-rpi4
  cancel-in-progress: false

jobs:
  # Build the kernel ISO on GitHub-hosted runner
  build-iso:
    name: Build ARM64 Kernel ISO
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'pull_request' && github.event.label.name == 'test-on-hardware')
    strategy:
      matrix:
        kernel: ${{ github.event_name == 'workflow_dispatch' && fromJSON(format('["{0}"]', github.event.inputs.test_kernel == 'All' && 'HelloWorld","Memory","TypeCasting' || github.event.inputs.test_kernel)) || fromJSON('["TypeCasting"]') }}

    outputs:
      iso_artifact: ${{ steps.upload.outputs.artifact-name }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 10.0.x

      - name: Clear NuGet Cache
        run: dotnet nuget locals all --clear

      - name: Build Cosmos Packages (ARM64)
        run: ./.devcontainer/postCreateCommand.sh arm64
        env:
          DOTNET_CLI_TELEMETRY_OPTOUT: 1
          DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1

      - name: Install Build Tools
        run: |
          sudo apt-get update
          sudo apt-get install -y xorriso lld gcc-aarch64-linux-gnu binutils-aarch64-linux-gnu

      - name: Build Kernel ISO
        run: |
          dotnet publish -c Debug -r linux-arm64 \
            -p:DefineConstants="ARCH_ARM64" \
            -p:CosmosArch=arm64 \
            ./tests/Kernels/Cosmos.Kernel.Tests.${{ matrix.kernel }}/Cosmos.Kernel.Tests.${{ matrix.kernel }}.csproj \
            -o ./output-arm64

      - name: Upload ISO Artifact
        id: upload
        uses: actions/upload-artifact@v4
        with:
          name: hardware-test-iso-${{ matrix.kernel }}-arm64
          path: |
            ./output-arm64/*.iso
            ./output-arm64/*.elf
          retention-days: 1

  # Run tests on self-hosted Raspberry Pi runner
  run-hardware-tests:
    name: Run on Raspberry Pi 4B - ${{ matrix.kernel }}
    needs: build-iso
    runs-on: [self-hosted, rpi4-test-board]
    timeout-minutes: 15
    strategy:
      fail-fast: false
      matrix:
        kernel: ${{ github.event_name == 'workflow_dispatch' && fromJSON(format('["{0}"]', github.event.inputs.test_kernel == 'All' && 'HelloWorld","Memory","TypeCasting' || github.event.inputs.test_kernel)) || fromJSON('["TypeCasting"]') }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            tools/rpi-test-board
            tests/Cosmos.TestRunner.Engine

      - name: Download ISO Artifact
        uses: actions/download-artifact@v4
        with:
          name: hardware-test-iso-${{ matrix.kernel }}-arm64
          path: ./iso

      - name: Find ISO File
        id: find-iso
        run: |
          ISO_PATH=$(find ./iso -name "*.iso" | head -1)
          if [ -z "$ISO_PATH" ]; then
            echo "Error: No ISO file found"
            exit 1
          fi
          echo "iso_path=$ISO_PATH" >> $GITHUB_OUTPUT
          echo "Found ISO: $ISO_PATH"

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Python Dependencies
        run: |
          pip install requests pyserial

      - name: Run Hardware Test
        id: run-test
        env:
          RPI_TEST_BOARD_ENDPOINT: ${{ secrets.RPI_TEST_BOARD_ENDPOINT }}
          RPI_TEST_BOARD_SERIAL: ${{ secrets.RPI_TEST_BOARD_SERIAL }}
          TEST_TIMEOUT: ${{ github.event.inputs.timeout || '180' }}
        run: |
          # Determine communication mode
          if [ -n "$RPI_TEST_BOARD_ENDPOINT" ]; then
            MODE="http"
            EXTRA_ARGS="--endpoint $RPI_TEST_BOARD_ENDPOINT"
          elif [ -n "$RPI_TEST_BOARD_SERIAL" ]; then
            MODE="serial"
            EXTRA_ARGS="--port $RPI_TEST_BOARD_SERIAL"
          else
            echo "Error: No test board configuration found"
            echo "Set RPI_TEST_BOARD_ENDPOINT or RPI_TEST_BOARD_SERIAL secret"
            exit 1
          fi

          python tools/rpi-test-board/scripts/rpi-test-controller.py \
            --mode $MODE \
            $EXTRA_ARGS \
            --iso "${{ steps.find-iso.outputs.iso_path }}" \
            --output uart-hardware-${{ matrix.kernel }}.log \
            --timeout $TEST_TIMEOUT

      - name: Parse Test Results
        if: always()
        run: |
          if [ -f "uart-hardware-${{ matrix.kernel }}.log" ]; then
            echo "=== UART Log ==="
            cat "uart-hardware-${{ matrix.kernel }}.log"
            echo ""
            echo "=== End of UART Log ==="

            # Check for test end marker
            if grep -q $'\xDE\xAD\xBE\xEF\xCA\xFE\xBA\xBE' "uart-hardware-${{ matrix.kernel }}.log" 2>/dev/null; then
              echo "Test suite completed (end marker found)"
            else
              echo "Warning: Test end marker not found"
            fi
          else
            echo "No UART log file found"
          fi

      - name: Upload UART Log
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: uart-hardware-${{ matrix.kernel }}-arm64
          path: uart-hardware-${{ matrix.kernel }}.log
          retention-days: 7

      - name: Generate Test Report
        if: always()
        run: |
          # Use the test runner to parse results
          if [ -f "uart-hardware-${{ matrix.kernel }}.log" ]; then
            # Build minimal test runner for parsing
            dotnet build tests/Cosmos.TestRunner.Engine/Cosmos.TestRunner.Engine.csproj -c Debug --verbosity quiet 2>/dev/null || true

            # For now, do basic parsing
            echo "## Hardware Test Results: ${{ matrix.kernel }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Platform | Raspberry Pi 4B |" >> $GITHUB_STEP_SUMMARY
            echo "| Architecture | ARM64 |" >> $GITHUB_STEP_SUMMARY
            echo "| Kernel | ${{ matrix.kernel }} |" >> $GITHUB_STEP_SUMMARY

            if [ -f "uart-hardware-${{ matrix.kernel }}.log" ]; then
              LOG_SIZE=$(wc -c < "uart-hardware-${{ matrix.kernel }}.log")
              echo "| UART Log Size | ${LOG_SIZE} bytes |" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

  # Post results to PR
  report-results:
    name: Report Results
    needs: [build-iso, run-hardware-tests]
    runs-on: ubuntu-latest
    if: always() && github.event_name == 'pull_request'
    steps:
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Post PR Comment
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Find all UART logs
            const artifactsDir = 'artifacts';
            let results = [];

            if (fs.existsSync(artifactsDir)) {
              const dirs = fs.readdirSync(artifactsDir);
              for (const dir of dirs) {
                if (dir.startsWith('uart-hardware-')) {
                  const logPath = path.join(artifactsDir, dir);
                  const files = fs.readdirSync(logPath);
                  for (const file of files) {
                    if (file.endsWith('.log')) {
                      const content = fs.readFileSync(path.join(logPath, file), 'utf8');
                      const kernel = dir.replace('uart-hardware-', '').replace('-arm64', '');
                      const hasEndMarker = content.includes('\xDE\xAD\xBE\xEF');
                      results.push({
                        kernel,
                        size: content.length,
                        completed: hasEndMarker
                      });
                    }
                  }
                }
              }
            }

            let body = `## ðŸ”§ Hardware Test Results (Raspberry Pi 4B)\n\n`;
            body += `| Kernel | Status | Log Size |\n`;
            body += `|--------|--------|----------|\n`;

            for (const r of results) {
              const status = r.completed ? 'âœ… Passed' : 'âŒ Failed/Incomplete';
              body += `| ${r.kernel} | ${status} | ${r.size} bytes |\n`;
            }

            if (results.length === 0) {
              body += `| - | No results | - |\n`;
            }

            body += `\nðŸ“‹ [View full run](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})\n`;
            body += `\nðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)`;

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            const botComment = comments.find(c => c.body.includes('## ðŸ”§ Hardware Test Results'));

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }
